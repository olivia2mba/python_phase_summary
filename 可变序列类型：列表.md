# 第七章 可变序列类型：列表

![](/assets/本书数据类型总结逻辑结构.png)

* ## 定义

1）可变类型的含义：支持原位改变

2）列表list定义：包含任意类型对象的有序集合，用 \[\] 表示

* ## 特性

1）含有多个元素

2）元素类型可以是任意类型

3）支持原位改变，序列长度可任意更改

4）有序序列，可通过索引值（偏移量）访问元素，列表名\[索引值\]

* ## 声明
* ### 声明方式1:直接将列表数据赋值给变量，可赋值给一个变量或多个变量

&gt;&gt;&gt; x = \[1, 2, 3\]

&gt;&gt;&gt; x

\[1, 2, 3\]

&gt;&gt;&gt; spam, spam1, spam2 = \['cat', 'bat', 'rat'\]

&gt;&gt;&gt; spam

'cat'

&gt;&gt;&gt; spam1

'bat'

&gt;&gt;&gt; spam =\[\['cat', 'bat'\], \[10, 20, 30, 40\]\]

&gt;&gt;&gt; spam

\[\['cat', 'bat'\], \[10, 20, 30, 40\]\]

* ### 声明方式2: 使用list\(\)函数

&gt;&gt;&gt; name = list\(‘优品课程’\)

\[‘优’,’品’,’课’,’程’\]

&gt;&gt;&gt; range\(5\)

range\(0, 5\)

&gt;&gt;&gt; list\(range\(5\)\)

\[0, 1, 2, 3, 4\]

* ## 通用操作：不管是对于可变序列类型还是不可变序列类型都通用的操作

**1）判断元素是否在序列内：**

**x in s 返回布尔值**

**x not in s 返回布尔值**

&gt;&gt;&gt; x = \[1, 2, \[2, 3\]\]

&gt;&gt;&gt; 1 in x

True

&gt;&gt;&gt; \[2, 3\] in x

True

&gt;&gt;&gt; 3 in x

False

&gt;&gt;&gt; 1 not in x

False

&gt;&gt;&gt; \[2\] not in x

True

**2）连接序列**

s1 + s2

&gt;&gt;&gt; x = list\(range\(4\)\)

&gt;&gt;&gt; x

\[0, 1, 2, 3\]

&gt;&gt;&gt; y = list\(range\(2,8,2\)\)

&gt;&gt;&gt; y

\[2, 4, 6\]

&gt;&gt;&gt; x + y

\[0, 1, 2, 3, 2, 4, 6\]

&gt;&gt;&gt; x

\[0, 1, 2, 3\]

**这个例子代表连接两个序列生成的是一个新序列，并不会改变原来序列。**

**3）重复序列元素 s \* n,n 代表数字**

&gt;&gt;&gt; x = \[1, 2, \[2, 3\]\]

&gt;&gt;&gt; x \* 3

\[1, 2, \[2, 3\], 1, 2, \[2, 3\], 1, 2, \[2, 3\]\]

&gt;&gt;&gt; x

\[1, 2, \[2, 3\]\]

**注意：同样返回的是一个新的序列值，对于原序列并不会改变**

4）**通过下标访问元素，-1代表最后一个元素**

&gt;&gt;&gt; x

\[1, 2, \[2, 3\]\]

&gt;&gt;&gt; x\[0\]

1

&gt;&gt;&gt; x\[2\]

\[2, 3\]

5\) **通过下标访问子序列，序列\[start : end : step\]。其中：step省略的情况下，默认step=1；start省略的情况下，默认start为=0；end省略的情况下，默认end=n-1,即为最后一个值。**

&gt;&gt;&gt; spam = \['cat', 'bat', 'rat', 'elephant'\]

&gt;&gt;&gt; spam\[0:4\]

\['cat', 'bat', 'rat', 'elephant'\]

&gt;&gt;&gt; spam\[1:3\]

\['bat', 'rat'\]

&gt;&gt;&gt; spam\[0:-1\]

\['cat', 'bat', 'rat'\]

**从上面结果可以看出，通过切片获取子序列，在end存在的情况下，子列表里的值不包含偏移量为end的这个元素。最后一个元素的偏移量为end-1.**

**实际，内存中索引是保存在两个值之间的缝隙，所以如果\[0:2\]代表0和2之间的元素**

![](/assets/屏幕快照 2017-03-20 下午10.44.58.png)

**也可以倒着切取列表的子列表，-1代表最后一个元素索引。**

![](/assets/屏幕快照 2017-03-20 下午10.46.13.png)

**6）获取列表长度函数len\(列表名\)**

&gt;&gt;&gt; x

\[1, 2, \[2, 3\]\]

&gt;&gt;&gt; len\(x\)

3

**7）获取最大，最小值：min\(s\), max\(s\) 前提：元素是具有可比较特点的; sum\(s\)总和**

&gt;&gt;&gt; x = \[2, 4, 7\]

&gt;&gt;&gt; min\(x\)

2

&gt;&gt;&gt; max\(x\)

7

&gt;&gt;&gt; sum\(x\)

13

**8）方法s.index\(\):检索某个元素第一个位置的下标**

&gt;&gt;&gt; x

\[2, 4, 7\]

&gt;&gt;&gt; x.index\(4\)

1

**9\) 方法s.count\(\): 计算某个元素出现在序列里的次数**

&gt;&gt;&gt; x

\[2, 4, 7\]

&gt;&gt;&gt; x.count\(7\)

1

* ## 特有操作

**1\) 通过索引改变某个位置的值**

&gt;&gt;&gt; x = list\(range\(2, 18, 3\)\)

&gt;&gt;&gt; x

\[2, 5, 8, 11, 14, 17\]

&gt;&gt;&gt; x \[3\] = \[2, 4\]

&gt;&gt;&gt; x

\[2, 5, 8, \[2, 4\], 14, 17\]

**2\)通过切片操作，改变子列表的值，形式为：s\[start:end:step\] = t,这里注意2点：a. t必须也是一个列表，但是t的列表元素个数不一定要和等号左边列表元素个数相等。 b. 在挚友step不等于1的情况下，t列表的元素个数才必须与左边列表元素个数相等。**

&gt;&gt;&gt; s = list\(range\(1, 11\)\)

&gt;&gt;&gt; s

\[1, 2, 3, 4, 5, 6, 7, 8, 9, 10\]

&gt;&gt;&gt; s\[:3\] = list\(range\(2,20,2\)\)

&gt;&gt;&gt; s

\[2, 4, 6, 8, 10, 12, 14, 16, 18, 4, 5, 6, 7, 8, 9, 10\]

&gt;&gt;&gt; s\[:5\] = \[999\]

&gt;&gt;&gt; s

\[999, 12, 14, 16, 18, 4, 5, 6, 7, 8, 9, 10\]

**这里注意：当t列表的元素个数小于左边列表元素个数的情况下，相当于删除列表元素的操作。**

**注意：如果使用步长的话，要给与等号左边相同元素数目的可迭代对象**

&gt;&gt;&gt; l\[::2\] = \[99, 99, 99, 99, 99\]

&gt;&gt;&gt; l

\[99, 2, 99, 4, 99, 6, 99, 8, 99, 10\]



